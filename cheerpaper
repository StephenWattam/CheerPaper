#!/usr/bin/env ruby
require 'net/http'
require 'logger'


# -----------------------------------------------------------------------------
#  Usage:
#
#  ./cheerpaper [WALLPAPER_PATH]
#
# Cheerpaper will look in your WALLPAPER_PATH for any images beginning with
# the colour called, and ending in one of the extensions as configured below.
#
# This is the list of colours I've seen, but it's not actually given anywhere,
# so there may be others:
#   red, orange, yellow, green, blue, cyan, magenta, white, 
#   warmwhite, black, and purple
# -----------------------------------------------------------------------------
 
# Keep your wallpapers in here
WALLPAPER_DIRECTORY   = ARGV[0] || "./wallpapers/" 
# Checks for these extensions
EXTENSIONS            = %w{png jpg jpeg gif}
# The command used to set wallpaper
WALLPAPER_CMD         = 'feh --bg-fill %s'
# Check this URL for the info
SERVICE_URL           = URI.parse('http://api.thingspeak.com//channels/1417/field/1/last.txt')
# Poll every n seconds
POLL_INTERVAL         = 30
# Check for the existence of this pid file
PID_FILE              = 'cheerpaper.pid'
# drop to background
DAEMONISE             = true 
# For use with cron, start, set and quit (no polling)
ONE_TIME              = false 
# Where to log
LOG                   = Logger.new STDOUT
# And the level
LOG.level             = Logger::INFO
# manual proxy settings (overrides environment variable http_proxy if set)
PROXY                 = nil #'http://username:password@proxyhost.com:8080'


# -----------------------------------------------------------------------------
# Retrieve a colour name from the web.
# Uses SERVICE_URL to download a name
def get_colour_name
  LOG.debug "Retrieving colour name from #{SERVICE_URL.host}:#{SERVICE_URL.port}#{SERVICE_URL.path}"

  # Load PROXY if set, else use envar
  proxstring = (ENV['http_proxy'] and PROXY == nil) ? ENV['http_proxy'].to_s : PROXY.to_s
  p = URI.parse (proxstring =~ /(^$|^http:\/\/.+)/i)? proxstring : "http://#{proxstring}"
  u = p.userinfo.to_s.split(/:/) 
  LOG.debug "Using proxy: #{proxstring}" if proxstring != ""

  # Build request path and gather response
  # NB: doesn't support redirects.
  req = Net::HTTP::Get.new(SERVICE_URL.path)
  res = Net::HTTP::Proxy(p.host, p.port, u[0], u[1]).start(SERVICE_URL.host, SERVICE_URL.port) {|http| http.request(req) }

  LOG.debug "Complete, retrieved: #{res}"
  return res.body.chomp.downcase
rescue Exception => e
  LOG.error "Error retrieving colour: #{e}"
  e.backtrace.each{|row| LOG.debug "    #{row}" }
  return nil
end


# Select a random image from WALLPAPER_DIRECTORY that
#  a) starts with the given prefix
#  b) ends with something in EXTENSIONS
def select_random_image(prefix)
  valid_images = []

  # check extension for each image with the prefix
  Dir.glob(File.join(WALLPAPER_DIRECTORY, "#{prefix}*")){|fn|
    valid_images << fn if EXTENSIONS.map{|x| ".#{x}"}.include?("#{File.extname(fn).downcase}")
  }

  LOG.debug "Found #{valid_images.length} image candidate[s] for prefix #{prefix}"
  valid_images.each{|row| LOG.debug "    #{row}" }
  return valid_images[ rand * valid_images.length ]
end


# Set the wallpaper to a given filepath
# uses WALLPAPER_CMD
def set_wallpaper(filepath)
  # Check the file is there
  return nil if filepath == nil
  raise "File not found" if not File.exist?(filepath)

  # construct and run command
  cmd = WALLPAPER_CMD % filepath
  `#{cmd}`

rescue Exception => e
  LOG.error "Error setting wallpaper: #{e}"
  e.backtrace.each{|row| LOG.debug "    #{row}" }
  return nil
end
# -----------------------------------------------------------------------------
# Entry point


# Check the wallpaper directory given exists
if not (File.exist?(WALLPAPER_DIRECTORY) and File.directory?(WALLPAPER_DIRECTORY)) then
  LOG.fatal "Wallpaper directory #{WALLPAPER_DIRECTORY} is not accessible, or is not a directory."
  LOG.info "To specify a wallpaper directory, provide it as an argument" if ARGV.length == 0 
  exit(1)
end

# Check for a pid file
if (not ONE_TIME) and File.exist?(PID_FILE) then
  LOG.fatal "CheerPaper is already running!"
  LOG.info "Please kill it or remove the pid file (#{PID_FILE})"
  exit(1)
end

# Daemonise.
if DAEMONISE and not ONE_TIME then
  LOG.info "Forking to background..."
  Process.daemon(true) 
end

# Write a pid file
if not ONE_TIME then
  LOG.debug "Writing pid file to #{PID_FILE}..."
  File.open(PID_FILE, 'w'){|fo| fo.write($$) }
end


begin
  curcol = nil
  loop do
    # Read the colour from the service
    nextcol = get_colour_name

    # Go on state change only
    if(nextcol != curcol)
      if( image = select_random_image(nextcol) )
        LOG.info "Setting background to #{image}"
        set_wallpaper(image)
        curcol = nextcol
      else
        LOG.error "Error setting wallpaper!"
      end
    end

    # and break out if requested
    break if ONE_TIME

    # Then sleep for the given time
    sleep(POLL_INTERVAL)
  end
rescue SignalException => Se
  LOG.fatal "Caught signal, closing..."
end

# Remove the pid file
if (not ONE_TIME) and File.exist?(PID_FILE) then
  LOG.debug "Removing pid file..."
  File.delete(PID_FILE) 
end
LOG.info "Goodbye."
